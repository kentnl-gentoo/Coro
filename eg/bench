#!/usr/bin/perl

# ->resume is not exactly cheap (it saves/restores a LOT
# of global variables), but shouldn't be slow. just to show
# how fast it is, this little proggie compares a normal subroutine
# call with two calls of transfer in a loop.

use Coro;
use Benchmark;

$a = bless {}, main::;

sub b {
   my ($self) = shift;
   $self->{b} = shift if @_;
   $self->{b};
}

$b = async {
   # do a little unrolling...
   while() {
      yield; yield; yield; yield; yield;
   }
};

yield;

$main = $Coro::main;

*transfer = \&Coro::State::transfer;

sub doit {
   while() {
      # some unrolling here as well..
      transfer($c, $main); transfer($c, $main);
      transfer($c, $main); transfer($c, $main);
      transfer($c, $main); transfer($c, $main);
   }
}

$c = Coro::State::_newprocess [sub {
   doit(1,2,3,4,5,6,7,8,9);
}];

transfer($main, $c);

timethese 100000, {
   empty    => '&a; &a',
   method   => '$a->b(5); $a->b(6)',
   yield    => 'yield',
   transfer => 'transfer($main, $c)',
};

